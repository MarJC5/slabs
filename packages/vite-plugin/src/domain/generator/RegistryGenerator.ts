import type { BlockDefinition } from '../types';

/**
 * RegistryGenerator
 *
 * Generates virtual module code (virtual:slabs-registry) from scanned blocks.
 * This code is served by Vite and imported by @slabs/client and @slabs/renderer.
 */
export class RegistryGenerator {
  /**
   * Generate complete virtual module code
   */
  generateModule(blocks: BlockDefinition[]): string {
    const imports = this.generateImports(blocks);
    const exports = this.generateExports(blocks);
    const metadata = this.generateMetadata(blocks);

    return `// Auto-generated by @slabs/vite-plugin
// DO NOT EDIT - This file is generated at build time

${imports}

${exports}

${metadata}
`;
  }

  /**
   * Generate import statements for all block files
   */
  generateImports(blocks: BlockDefinition[]): string {
    const imports: string[] = [];

    for (const block of blocks) {
      const varName = this.getVarName(block.name);

      // Import edit function
      imports.push(
        `import { render as ${varName}Edit } from '${this.getRelativePath(block.files.editPath)}';`
      );

      // Import save function
      imports.push(
        `import { save as ${varName}Save } from '${this.getRelativePath(block.files.savePath)}';`
      );

      // Import render function
      imports.push(
        `import { render as ${varName}Render } from '${this.getRelativePath(block.files.renderPath)}';`
      );

      // Import preview image (optional)
      if (block.files.previewPath) {
        imports.push(
          `import ${varName}Preview from '${this.getRelativePath(block.files.previewPath)}';`
        );
      }

      // Import styles (optional)
      if (block.files.stylePath) {
        imports.push(
          `import '${this.getRelativePath(block.files.stylePath)}';`
        );
      }

      imports.push(''); // Empty line between blocks
    }

    return `// === IMPORTS ===\n${imports.join('\n')}`;
  }

  /**
   * Generate exports object with all blocks
   */
  generateExports(blocks: BlockDefinition[]): string {
    const blockEntries: string[] = [];

    for (const block of blocks) {
      const varName = this.getVarName(block.name);

      blockEntries.push(`  '${block.name}': {
    edit: ${varName}Edit,
    save: ${varName}Save,
    render: ${varName}Render,${block.files.previewPath ? `\n    preview: ${varName}Preview,` : ''}
    meta: ${JSON.stringify(block.meta, null, 6).replace(/\n/g, '\n    ')}
  }`);
    }

    return `// === EXPORTS ===
export const blocks = {
${blockEntries.join(',\n')}
};`;
  }

  /**
   * Generate metadata about the registry
   */
  generateMetadata(blocks: BlockDefinition[]): string {
    return `// === METADATA ===
export const metadata = {
  version: '1.0.0',
  totalBlocks: ${blocks.length},
  generatedAt: '${new Date().toISOString()}'
};`;
  }

  /**
   * Generate TypeScript type declarations
   */
  generateTypes(blocks: BlockDefinition[]): string {
    const blockNames = blocks.map(b => `'${b.name}'`).join(' | ');

    return `declare module 'virtual:slabs-registry' {
  export interface BlockDefinition {
    edit: (context: EditContext) => HTMLElement;
    save: (element: HTMLElement) => any;
    render: (data: any, context?: RenderContext) => HTMLElement;
    preview?: string;
    meta: BlockMetadata;
  }

  export interface BlockMetadata {
    name: string;
    title: string;
    category?: string;
    description?: string;
    keywords?: string[];
    version?: string;
    icon?: string;
    attributes?: Record<string, AttributeSchema>;
    supports?: BlockSupports;
    dependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
  }

  export const blocks: Record<${blockNames || 'string'}, BlockDefinition>;
  export const metadata: {
    version: string;
    totalBlocks: number;
    generatedAt: string;
  };
}
`;
  }

  /**
   * Convert block name to valid JavaScript variable name
   * Example: "slabs/simple-text" -> "slabsSimpleText"
   */
  private getVarName(blockName: string): string {
    return blockName
      .replace(/[^a-zA-Z0-9]+/g, '-')
      .split('-')
      .filter(Boolean)
      .map((part, index) => {
        if (index === 0) return part.toLowerCase();
        return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
      })
      .join('');
  }

  /**
   * Convert absolute path to relative path for imports
   * Ensures proper forward slashes for import statements
   */
  private getRelativePath(absolutePath: string): string {
    // For now, return as-is (will be resolved by Vite)
    // In real implementation, convert to relative path from virtual module location
    return absolutePath.replace(/\\/g, '/');
  }
}
