import type { BlockDefinition } from '../types';

/**
 * RegistryGenerator
 *
 * Generates virtual module code (virtual:slabs-registry) from scanned blocks.
 * This code is served by Vite and imported by @slabs/client and @slabs/renderer.
 */
export class RegistryGenerator {
  /**
   * Generate complete virtual module code
   */
  generateModule(blocks: BlockDefinition[]): string {
    const imports = this.generateImports(blocks);
    const helpers = this.generateHelpers(blocks);
    const exports = this.generateExports(blocks);
    const metadata = this.generateMetadata(blocks);

    return `// Auto-generated by @slabs/vite-plugin
// DO NOT EDIT - This file is generated at build time

${imports}

${helpers}

${exports}

${metadata}
`;
  }

  /**
   * Generate import statements for all block files
   */
  generateImports(blocks: BlockDefinition[]): string {
    const imports: string[] = [];

    for (const block of blocks) {
      const varName = this.getVarName(block.name);

      // Import edit function
      imports.push(
        `import { render as ${varName}Edit } from '${this.getRelativePath(block.files.editPath)}';`
      );

      // Import save function
      imports.push(
        `import { save as ${varName}Save } from '${this.getRelativePath(block.files.savePath)}';`
      );

      // Import render function or component
      const renderPath = block.files.renderPath;
      if (renderPath.endsWith('.vue')) {
        // Vue SFC - import default export
        imports.push(
          `import ${varName}RenderComponent from '${this.getRelativePath(renderPath)}';`
        );
      } else if (renderPath.endsWith('.tsx') || renderPath.endsWith('.jsx')) {
        // React component - check if it exports a render function or default component
        imports.push(
          `import * as ${varName}RenderModule from '${this.getRelativePath(renderPath)}';`
        );
      } else {
        // Standard TS/JS file - import named render export
        imports.push(
          `import { render as ${varName}Render } from '${this.getRelativePath(renderPath)}';`
        );
      }

      // Import preview image (optional)
      if (block.files.previewPath) {
        imports.push(
          `import ${varName}Preview from '${this.getRelativePath(block.files.previewPath)}';`
        );
      }

      // Import styles (optional)
      if (block.files.stylePath) {
        imports.push(
          `import '${this.getRelativePath(block.files.stylePath)}';`
        );
      }

      imports.push(''); // Empty line between blocks
    }

    return `// === IMPORTS ===\n${imports.join('\n')}`;
  }

  /**
   * Generate helper functions for component wrapping
   */
  generateHelpers(blocks: BlockDefinition[]): string {
    const hasVue = blocks.some(b => b.files.renderPath.endsWith('.vue'));
    const hasReact = blocks.some(b =>
      b.files.renderPath.endsWith('.tsx') || b.files.renderPath.endsWith('.jsx')
    );

    const helpers: string[] = ['// === HELPERS ==='];

    if (hasVue) {
      helpers.push(`
// Helper to wrap Vue SFCs
import { createApp as __createVueApp, h as __h } from 'vue';
function __wrapVueComponent(component, data, context) {
  const container = document.createElement('div');
  const app = __createVueApp({
    render: () => __h(component, { data, context })
  });
  app.mount(container);
  return container.firstElementChild;
}`);
    }

    if (hasReact) {
      helpers.push(`
// Helper to wrap React components
import { renderToStaticMarkup as __renderToStaticMarkup } from 'react-dom/server';
import { createElement as __createElement } from 'react';
function __wrapReactComponent(Component, data, context) {
  const html = __renderToStaticMarkup(__createElement(Component, { data, context }));
  const temp = document.createElement('div');
  temp.innerHTML = html;
  return temp.firstElementChild;
}`);
    }

    return helpers.join('\n');
  }

  /**
   * Generate exports object with all blocks
   */
  generateExports(blocks: BlockDefinition[]): string {
    const blockEntries: string[] = [];

    for (const block of blocks) {
      const varName = this.getVarName(block.name);
      const renderPath = block.files.renderPath;

      // Determine render function based on file extension
      let renderFunction: string;
      if (renderPath.endsWith('.vue')) {
        renderFunction = `(data, context) => __wrapVueComponent(${varName}RenderComponent, data, context)`;
      } else if (renderPath.endsWith('.tsx') || renderPath.endsWith('.jsx')) {
        // Support both default export (component) and named export (render function)
        renderFunction = `(data, context) => {
      if (${varName}RenderModule.render) {
        return ${varName}RenderModule.render(data, context);
      } else if (${varName}RenderModule.default) {
        return __wrapReactComponent(${varName}RenderModule.default, data, context);
      }
      throw new Error('${block.name}: render.tsx must export either a render function or default component');
    }`;
      } else {
        renderFunction = `${varName}Render`;
      }

      blockEntries.push(`  '${block.name}': {
    edit: ${varName}Edit,
    save: ${varName}Save,
    render: ${renderFunction},${block.files.previewPath ? `\n    preview: ${varName}Preview,` : ''}
    meta: ${JSON.stringify(block.meta, null, 6).replace(/\n/g, '\n    ')}
  }`);
    }

    return `// === EXPORTS ===
export const blocks = {
${blockEntries.join(',\n')}
};`;
  }

  /**
   * Generate metadata about the registry
   */
  generateMetadata(blocks: BlockDefinition[]): string {
    return `// === METADATA ===
export const metadata = {
  version: '1.0.0',
  totalBlocks: ${blocks.length},
  generatedAt: '${new Date().toISOString()}'
};`;
  }

  /**
   * Generate TypeScript type declarations
   */
  generateTypes(blocks: BlockDefinition[]): string {
    const blockNames = blocks.map(b => `'${b.name}'`).join(' | ');

    return `declare module 'virtual:slabs-registry' {
  export interface BlockDefinition {
    edit: (context: EditContext) => HTMLElement;
    save: (element: HTMLElement) => any;
    render: (data: any, context?: RenderContext) => HTMLElement;
    preview?: string;
    meta: BlockMetadata;
  }

  export interface BlockMetadata {
    name: string;
    title: string;
    category?: string;
    description?: string;
    keywords?: string[];
    version?: string;
    icon?: string;
    attributes?: Record<string, AttributeSchema>;
    supports?: BlockSupports;
    dependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
  }

  export const blocks: Record<${blockNames || 'string'}, BlockDefinition>;
  export const metadata: {
    version: string;
    totalBlocks: number;
    generatedAt: string;
  };
}
`;
  }

  /**
   * Convert block name to valid JavaScript variable name
   * Example: "slabs/simple-text" -> "slabsSimpleText"
   */
  private getVarName(blockName: string): string {
    return blockName
      .replace(/[^a-zA-Z0-9]+/g, '-')
      .split('-')
      .filter(Boolean)
      .map((part, index) => {
        if (index === 0) return part.toLowerCase();
        return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
      })
      .join('');
  }

  /**
   * Convert absolute path to relative path for imports
   * Ensures proper forward slashes for import statements
   */
  private getRelativePath(absolutePath: string): string {
    // For now, return as-is (will be resolved by Vite)
    // In real implementation, convert to relative path from virtual module location
    return absolutePath.replace(/\\/g, '/');
  }
}
